# 装饰器的实质

对于装饰器而言，实际上是一个函数，只不过其参数也是个函数。应当注意的是传递函数时应使用其函数名而不加括号，其函数名将作为参数而传递。

 语法有如下两种：

```text
1.def a(f):
	def lmt():
		print('lmt')
		f()
	return lmt
def dyf():
	print('dyf')

dyf()
dyf = a(dyf)
dyf()
print(dyf.__name__)
输出结果为：
					dyf
					lmt
					dyf
					lmt      #dyf函数的名和注释文档被重写(docstring)  以你之名诶o_o
=============================================================================
```

```text
2.def a(f):
	@wraps(f)  @这个函数保留原函数名
	def lmt():
		print('lmt')
		f()
	return lmt
@a
def dyf():
	print('dyf')
dyf()	
输出结果为:
				lmt
				dyf
```

以上两种方式效果完全相同，只是@方式是其简便写法，装饰器的本质即 以函数调用函数的方式来对被调用函数进行修饰，但要注意 在函数调用的过程中应当以函数名作为参数 在执行函数时才加括号。

 若要保留被装饰函数的真是名需要调用functools模块的wraps\(\)函数，语法为 @wraps\(f\)，实际上wraps\(\)函数本身就是一个装饰器，只不过其参数是一个函数罢了。

